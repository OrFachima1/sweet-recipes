<!doctype html>
<html dir="ltr" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF.js Mini Viewer</title>
  <!-- Uses local UMD builds you copied to /public/pdfjs/vendor -->
  <link rel="stylesheet" href="/pdfjs/vendor/pdf_viewer.css" />
  <style>
    html,body { height:100%; margin:0 }
    #viewerContainer { position:fixed; inset:0; overflow:auto; background:#fff; touch-action: pan-x pan-y; }
    .pdfViewer .page { margin:8px auto; border:1px solid #e5e7eb; box-shadow:0 1px 3px rgba(0,0,0,.06) }

    /* Toolbar (top-left by default) */
    .toolbar{
      position: fixed;
      left: 12px; top: 12px; right: auto; bottom: auto;   /* default: top-left */
      display: flex; gap: 8px;
      background: rgba(255,255,255,.92);
      border: 1px solid #e5e7eb; border-radius: 12px;
      padding: 6px; box-shadow: 0 2px 6px rgba(0,0,0,.08); z-index: 10;
      -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
      cursor: move; /* draggable handle */
    }
    .toolbar button {
      min-width: 44px; height: 36px; border: 1px solid #e5e7eb; border-radius: 10px;
      background: #fff; font: 600 14px system-ui, Segoe UI, Arial; cursor: pointer;
    }
    .toolbar button:active { transform: scale(.98); }

    #err {
      position:fixed; left:8px; bottom:8px; font:12px/1.4 system-ui,Segoe UI,Arial;
      color:#b91c1c; background:#fee2e2; padding:6px 8px; border-radius:8px; display:none; max-width:90vw;
    }
  </style>
</head>
<body>
  <div id="viewerContainer"><div id="viewer" class="pdfViewer"></div></div>

  <!-- Zoom toolbar (draggable) -->
  <div id="toolbar" class="toolbar">
    <button id="zoomOut"  title="Zoom Out">−</button>
    <button id="zoomReset" title="Reset">100%</button>
    <button id="zoomIn"   title="Zoom In">+</button>
  </div>

  <div id="err"></div>

  <!-- UMD builds served locally from /public/pdfjs/vendor -->
  <script src="/pdfjs/vendor/pdf.js"></script>
  <script src="/pdfjs/vendor/pdf_viewer.js"></script>

  <script>
    (function () {
      const showErr = (msg) => { const el = document.getElementById('err'); el.textContent = msg; el.style.display = 'block'; };

      try {
        const pdfjsLib    = window['pdfjs-dist/build/pdf'];
        const pdfjsViewer = window['pdfjs-dist/web/pdf_viewer'];
        pdfjsLib.GlobalWorkerOptions.workerSrc = "/pdfjs/vendor/pdf.worker.js";

        const params = new URLSearchParams(location.search);
        const file = params.get("file");
        if (!file) { showErr("Missing ?file=…"); return; }

        const eventBus    = new pdfjsViewer.EventBus();
        const linkService = new pdfjsViewer.PDFLinkService({ eventBus });

        const container = document.getElementById("viewerContainer");
        const viewer = new pdfjsViewer.PDFViewer({
          container,
          eventBus,
          linkService,      // pass via ctor (no setLinkService in this UMD)
          textLayerMode: 2, // required for highlights
        });
        linkService.setViewer(viewer);

        const findController = new pdfjsViewer.PDFFindController({ eventBus, linkService, pdfViewer: viewer });
        if (typeof viewer.setFindController === "function") viewer.setFindController(findController);
        else viewer.findController = findController; // rare fallback

        // ===== Zoom helpers =====
        const MIN_SCALE = 0.5, MAX_SCALE = 3.0, STEP = 0.1;
        const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

        function updateZoomLabel() {
          const btn = document.getElementById("zoomReset");
          const pct = Math.round((viewer.currentScale || 1) * 100);
          if (btn) btn.textContent = pct + "%";
        }

        function setScaleAt(newScale, clientX, clientY) {
          newScale = clamp(newScale, MIN_SCALE, MAX_SCALE);
          const rect = container.getBoundingClientRect();
          const preW = container.scrollWidth, preH = container.scrollHeight;

          // percentages of scroll relative to the point
          const px = (container.scrollLeft + (clientX - rect.left)) / Math.max(1, preW);
          const py = (container.scrollTop  + (clientY - rect.top )) / Math.max(1, preH);

          viewer.currentScale = newScale;
          updateZoomLabel();

          requestAnimationFrame(() => {
            const postW = container.scrollWidth, postH = container.scrollHeight;
            container.scrollLeft = px * postW - (clientX - rect.left);
            container.scrollTop  = py * postH - (clientY - rect.top);
          });
        }

        function setScale(newScale) {
          const rect = container.getBoundingClientRect();
          setScaleAt(newScale, rect.left + container.clientWidth/2, rect.top + container.clientHeight/2);
        }
        function zoomIn()  { setScale((viewer.currentScale || 1) + STEP); }
        function zoomOut() { setScale((viewer.currentScale || 1) - STEP); }
        function zoomReset(){ setScale(1); }

        // Toolbar buttons
        document.getElementById("zoomIn")  ?.addEventListener("click", zoomIn);
        document.getElementById("zoomOut") ?.addEventListener("click", zoomOut);
        document.getElementById("zoomReset")?.addEventListener("click", zoomReset);

        // Keyboard: Ctrl/Cmd + (+ / - / 0)
        window.addEventListener("keydown", (e) => {
          if (!(e.ctrlKey || e.metaKey)) return;
          if (e.key === "+" || e.key === "=") { e.preventDefault(); zoomIn(); }
          if (e.key === "-") { e.preventDefault(); zoomOut(); }
          if (e.key === "0") { e.preventDefault(); zoomReset(); }
        });

        // Wheel zoom with Ctrl/Cmd (also covers mac trackpad pinch)
        container.addEventListener("wheel", (e) => {
          if (!(e.ctrlKey || e.metaKey)) return;
          e.preventDefault();
          const factor = e.deltaY < 0 ? 1.05 : 0.95;
          const newScale = (viewer.currentScale || 1) * factor;
          setScaleAt(newScale, e.clientX, e.clientY);
        }, { passive: false });

        // Pinch zoom (mobile, two fingers)
        let pinchStartDist = null, pinchStartScale = 1, pinchMid = { x: 0, y: 0 };
        container.addEventListener("touchstart", (e) => {
          if (e.touches.length === 2) {
            const [t1, t2] = e.touches;
            const dx = t1.clientX - t2.clientX, dy = t1.clientY - t2.clientY;
            pinchStartDist = Math.hypot(dx, dy);
            pinchStartScale = viewer.currentScale || 1;
            pinchMid = { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
          } else {
            pinchStartDist = null;
          }
        }, { passive: true });
        container.addEventListener("touchmove", (e) => {
          if (e.touches.length === 2 && pinchStartDist) {
            e.preventDefault(); // prevent browser default zoom
            const [t1, t2] = e.touches;
            const dx = t1.clientX - t2.clientX, dy = t1.clientY - t2.clientY;
            const dist = Math.hypot(dx, dy);
            const scale = clamp(pinchStartScale * (dist / pinchStartDist), MIN_SCALE, MAX_SCALE);
            setScaleAt(scale, pinchMid.x, pinchMid.y);
          }
        }, { passive: false });
        container.addEventListener("touchend", (e) => {
          if (pinchStartDist && e.touches?.length < 2) pinchStartDist = null;
        });

        // Double-tap (single finger) to zoom-in around the tap point
        let prevTapTime = 0, prevTapX = 0, prevTapY = 0;
        container.addEventListener("touchend", (e) => {
          if (e.touches.length > 0 || e.changedTouches.length === 0) return;
          const t = e.changedTouches[0];
          const now = Date.now();
          const dt = now - prevTapTime;
          const dist = Math.hypot(t.clientX - prevTapX, t.clientY - prevTapY);
          if (dt < 300 && dist < 30) {
            const newScale = (viewer.currentScale || 1) * 1.5;
            setScaleAt(newScale, t.clientX, t.clientY);
            prevTapTime = 0;
          } else {
            prevTapTime = now; prevTapX = t.clientX; prevTapY = t.clientY;
          }
        }, { passive: true });

        // ===== Draggable toolbar (persist position) =====
        const tb = document.getElementById('toolbar');
        if (tb) {
          const loadPos = () => {
            try {
              const p = JSON.parse(localStorage.getItem('pdfjs-toolbar-pos') || 'null');
              if (!p) return;
              const w = window.innerWidth, h = window.innerHeight;
              const bw = tb.offsetWidth, bh = tb.offsetHeight;
              const l = Math.max(0, Math.min(w - bw - 4, parseFloat(p.left)));
              const t = Math.max(0, Math.min(h - bh - 4, parseFloat(p.top)));
              tb.style.left = l + 'px'; tb.style.top = t + 'px';
              tb.style.right = 'auto'; tb.style.bottom = 'auto';
            } catch {}
          };
          loadPos();

          let drag = false, moved = false, sx = 0, sy = 0, sl = 0, st = 0;
          tb.addEventListener('pointerdown', (e) => {
            const tgt = e.target;
            if (tgt && tgt.closest && tgt.closest('button')) return; // don't start drag from buttons
            drag = true; moved = false;
            sx = e.clientX; sy = e.clientY;
            const r = tb.getBoundingClientRect(); sl = r.left; st = r.top;
            tb.setPointerCapture && tb.setPointerCapture(e.pointerId);
          });
          window.addEventListener('pointermove', (e) => {
            if (!drag) return;
            const dx = e.clientX - sx, dy = e.clientY - sy;
            if (Math.abs(dx) + Math.abs(dy) > 3) moved = true;
            const w = window.innerWidth, h = window.innerHeight;
            const bw = tb.offsetWidth, bh = tb.offsetHeight;
            let l = sl + dx, t = st + dy;
            l = Math.max(0, Math.min(w - bw - 4, l));
            t = Math.max(0, Math.min(h - bh - 4, t));
            tb.style.left = l + 'px'; tb.style.top = t + 'px';
            tb.style.right = 'auto'; tb.style.bottom = 'auto';
          }, { passive: true });
          window.addEventListener('pointerup', (e) => {
            if (!drag) return; drag = false;
            tb.releasePointerCapture && tb.releasePointerCapture(e.pointerId);
            const left = parseFloat(tb.style.left) || 0;
            const top  = parseFloat(tb.style.top)  || 0;
            localStorage.setItem('pdfjs-toolbar-pos', JSON.stringify({ left, top }));
            setTimeout(() => { moved = false; }, 0);
          });
          tb.addEventListener('click', (e) => { if (moved) { e.stopPropagation(); e.preventDefault(); } }, true);
          window.addEventListener('resize', loadPos);
        }

        // ===== Load PDF & search handling =====
        pdfjsLib.getDocument({ url: file }).promise.then(function (pdfDoc) {
          viewer.setDocument(pdfDoc);
          linkService.setDocument(pdfDoc);
          updateZoomLabel();

          const m = (location.hash || "").match(/search=([^&]+)/);
          const initial = m ? decodeURIComponent(m[1]) : "";
          const doFind = (q) => q && eventBus.dispatch("find", {
            source: window, type: "again", query: q,
            caseSensitive: false, entireWord: false, highlightAll: true, findPrevious: false,
          });
          if (initial) setTimeout(() => doFind(initial), 150);

          window.addEventListener("message", (e) => {
            const d = e.data || {};
            if (d.type === "find" && typeof d.query === "string") doFind(d.query);
          });
        }).catch(function (err) {
          console.error(err);
          showErr("Failed to load PDF: " + (err && err.message ? err.message : String(err)));
        });

      } catch (e) {
        console.error(e);
        showErr("Viewer error: " + (e && e.message ? e.message : String(e)));
      }
    })();
  </script>
</body>
</html>
